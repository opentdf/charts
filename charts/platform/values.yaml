# Default values for chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# -- The number of Platform pods to run
replicaCount: 1

image:
  # -- The image repository to pull from
  repository: registry.opentdf.io/platform
  # -- The image tag to pull policy
  pullPolicy: IfNotPresent
  # -- Overrides the image tag whose default is the chart appVersion.
  tag: ""

# -- The image pull secrets to use
imagePullSecrets: []
# -- Overrides the chart name
nameOverride: ""
# -- Overrides the generated fullname
fullnameOverride: ""

serviceAccount:
  # -- Specifies whether a service account should be created
  create: true
  # -- Automatically mount a ServiceAccount's API credentials
  automount: true
  # -- Extra annotations to add to the service account
  annotations: {}
  # -- The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# -- Extra annotations to add to the pod
podAnnotations: {}
# -- Extra labels to add to the pod
podLabels: {}

# -- The pod security context
podSecurityContext:
  {}
  # fsGroup: 2000

# -- The container security context
securityContext:
  {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  # -- The type of service to create
  type: ClusterIP
  # -- The port of the service
  port: 9000
  # -- Extra annotations to add to the service
  annotations: {}

ingress:
  # -- Enable Ingress
  enabled: false
  # -- Ingress class name if required
  className: ""
  # -- Extra Ingress annotations
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  # -- List of hosts for the ingress
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  # -- List of tls hosts
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# -- Resources to allocate to the container
resources:
  {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

autoscaling:
  # -- Enable horizontal autoscaling
  enabled: false
  # -- Minimum number of pods to run
  minReplicas: 1
  # -- Maximum number of pods to run
  maxReplicas: 100
  # -- Target CPU utilization percentage
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# -- Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# -- Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

# -- Target specific nodes in the cluster
nodeSelector: {}

# -- Tolerations to apply to the pod (https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/)
tolerations: []

# -- Affinity settings for pod assignment
affinity: {}

# -- Extra environment variables to add to the container
extraEnv: []
# - name: SAMPLE_ENV
#   value: sample
# - name: SECRET
#   valueFrom:
#     secretKeyRef:
#       name: mysecret
#       key: mykey

# -- Environment variables from a configmap or secret 
envFrom: []
# - configMapRef:
#     name: configmap
# - secretRef:
#     name: secret

logger:
  # -- The platform log level ( debug, info, warn, error )
  level: info
  # -- The platform log format ( json, text )
  type: json
  # -- The platform log output
  output: stdout

db:
  # --  The database host
  host: platform-db
  # -- The database port
  port: 5432
  # -- The database name
  database: opentdf
  # -- The database user
  user: opentdf
  # -- The database ssl mode ( disable, prefer, require, verify-ca, verify-full )
  sslmode: prefer
  password:
    secret:
      # -- The kubernetes secret containing the database user password
      name: opentdf-db-credentials
      # -- The key in the secret containing the database user password
      key: password

server:
  # -- The server port
  port: 9000
  # -- Enable go pprof
  enable_pprof: false
  cors:
    # -- Enable CORS (default: false)
    enabled: false
    # -- The allowed origins
    allowedorigins: []
      # - "*"
    # -- The allowed request methods
    allowedmethods: 
      - "GET"
      - "POST"
      - "PUT"
      - "DELETE"
      - "OPTIONS"
    # -- The allowed request headers
    allowedheaders:
      - "Accept"
      - "Authorization"
      - "Content-Type"
      - "X-CSRF-Token"
      - "X-Request-ID"
    # -- List of response headers that browsers are allowed to access
    exposedheaders:
      - Link
    # -- The max age
    maxage: 3600
    # -- Allow credentials
    allowcredentials: true
  grpc:
    # -- Enables grpc reflection (https://github.com/grpc/grpc/blob/master/doc/server-reflection.md)
    reflectionEnabled: true
  # -- Disable Kubernetes Health Checks. (Useful for debugging)
  disableHealthChecks: false
  tls:
    # -- Enables tls for platform server
    enabled: false
    # -- The server tls certificate. If not set, a self-signed certificate is generated
    secret:
    # -- Additional trusted certificates. These can be loaded following [projected volume](https://kubernetes.io/docs/concepts/storage/projected-volumes/)
    additionalTrustedCerts:
      []
      # - secret:
      #     name: app-certs
      #     optional: false
      #     items:
      #       - key: cert.pem
      #         path: app-cert.pem
  auth:
    # -- Audience of provided by the identity provider
    audience: "http://localhost:8080"
    # -- Identity provider issuer
    issuer: http://platform-keycloak/realms/opentdf
    policy:
      ## -- Default policy for all requests
      default: #  "role:readonly"
      ## -- Dot notation is used to access nested claims (i.e. realm_access.roles)
      claim: #  realm_access.roles
      ## -- Maps the external role to the opentdf role
      ## Note: left side is used in the policy, right side is the external role
      map:
      #  readonly: opentdf-readonly
      #  admin: opentdf-admin
      #  org-admin: opentdf-org-admin

      ## -- Custom policy (see examples https://github.com/casbin/casbin/tree/master/examples)
      csv: #  |
      #  p, role:org-admin, policy:attributes, *, *, allow
      #  p, role:org-admin, policy:subject-mappings, *, *, allow
      #  p, role:org-admin, policy:resource-mappings, *, *, allow
      #  p, role:org-admin, policy:kas-registry, *, *, allow
  cryptoProvider:
    standard:
      # -- List of key pairs to load into the platform. (Currently only leveraged by KAS)
      keys:
        - kid: r1
          alg: rsa:2048
          private: /etc/platform/kas/kas-private.pem
          cert: /etc/platform/kas/kas-cert.pem
        - kid: e1
          alg: ec:secp256r1
          private: /etc/platform/kas/kas-ec-private.pem
          cert: /etc/platform/kas/kas-ec-cert.pem
services:
  entityresolution:
    # -- Entity Resolver service enabled
    enabled: false
    # -- Identity Provider Entity Resolver
    url:
    # -- Client Id for Entity Resolver
    clientid: 
    # -- Client Secret for Entity Resolver
    clientsecret:
    # -- Entity Resolver Realm
    realm: 
    # -- Subgroups 
    subgroups: false

  kas:
    # -- KAS service Configuration as yaml
    config:
      # -- KAS service enabled
      enabled: true
      # -- Default keys for clients to use
      keyring:
        - kid: e1
          alg: ec:secp256r1
        - kid: r1
          alg: rsa:2048
    # -- KAS secret containing keys
    # kas-private.pem , kas-cert.pem , kas-ec-private.pem , kas-ec-cert.pem
    privateKeysSecret: kas-private-keys
  authorization:
    # -- Authorization service enabled
    enabled: true
    # -- External entity store (currently only keycloak is supported)
    ersurl: http://localhost:9000/entityresolution/resolve
    # -- Client id for the external entity store
    clientid:
    # -- Client secret for the external entity store
    clientsecret: 
    # -- Oauth2 Server Token Endpoint 
    tokenendpoint: 
    # -- Overide embedded rego policy
    # rego:
    #   path: /etc/platform/entitlements.rego

  # -- Additional services
  extraServices: {}
  # -- Example of extra service
  # myservice:
  #   enabled: true
  #   url: http://localhost:8080

#############################################
# The following values are for testing only #
#############################################

playground: false

postgresql:
  fullnameOverride: platform-db
  auth:
    database: opentdf
    usePasswordFiles: true
    enablePostgresUser: false
    username: opentdf
    existingSecret: opentdf-db-credentials
    secretKeys:
      userPasswordKey: password
  tls:
    enabled: true
    autoGenerated: true

keycloak:
  extraEnvVars:
  - name: KC_FEATURES
    value: "preview,token-exchange"
  tls:
    enabled: true
    autoGenerated: true
  fullnameOverride: platform-keycloak
  postgresql:
    enabled: false
  externalDatabase:
    host: platform-db
    port: 5432
    database: opentdf
    user: opentdf
    existingSecret: opentdf-db-credentials # The needs to align with the db.password.secret configuration
    existingSecretPasswordKey: password
  auth:
    adminUser: admin
  keycloakConfigCli:
    enabled: true
    configuration:
      opentdf.json: |
        {
          "realm":"opentdf",
          "enabled": true,
          "clients": []
        }
  proxy: edge
  ingress:
    enabled: true
    tls: true
    selfSigned: true
    labels:
      "opentdf.io/keycloak-admin": "false"
